// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: notepad.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_notepad_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_notepad_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_notepad_2eproto;
namespace notepad {
class GIST;
struct GISTDefaultTypeInternal;
extern GISTDefaultTypeInternal _GIST_default_instance_;
class PROJECT;
struct PROJECTDefaultTypeInternal;
extern PROJECTDefaultTypeInternal _PROJECT_default_instance_;
class PROJECT_LIST;
struct PROJECT_LISTDefaultTypeInternal;
extern PROJECT_LISTDefaultTypeInternal _PROJECT_LIST_default_instance_;
class USER;
struct USERDefaultTypeInternal;
extern USERDefaultTypeInternal _USER_default_instance_;
class USER_BOOK;
struct USER_BOOKDefaultTypeInternal;
extern USER_BOOKDefaultTypeInternal _USER_BOOK_default_instance_;
class VERSION_POINTER;
struct VERSION_POINTERDefaultTypeInternal;
extern VERSION_POINTERDefaultTypeInternal _VERSION_POINTER_default_instance_;
}  // namespace notepad
PROTOBUF_NAMESPACE_OPEN
template<> ::notepad::GIST* Arena::CreateMaybeMessage<::notepad::GIST>(Arena*);
template<> ::notepad::PROJECT* Arena::CreateMaybeMessage<::notepad::PROJECT>(Arena*);
template<> ::notepad::PROJECT_LIST* Arena::CreateMaybeMessage<::notepad::PROJECT_LIST>(Arena*);
template<> ::notepad::USER* Arena::CreateMaybeMessage<::notepad::USER>(Arena*);
template<> ::notepad::USER_BOOK* Arena::CreateMaybeMessage<::notepad::USER_BOOK>(Arena*);
template<> ::notepad::VERSION_POINTER* Arena::CreateMaybeMessage<::notepad::VERSION_POINTER>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace notepad {

// ===================================================================

class USER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.USER) */ {
 public:
  inline USER() : USER(nullptr) {}
  ~USER() override;
  explicit PROTOBUF_CONSTEXPR USER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  USER(const USER& from);
  USER(USER&& from) noexcept
    : USER() {
    *this = ::std::move(from);
  }

  inline USER& operator=(const USER& from) {
    CopyFrom(from);
    return *this;
  }
  inline USER& operator=(USER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const USER& default_instance() {
    return *internal_default_instance();
  }
  static inline const USER* internal_default_instance() {
    return reinterpret_cast<const USER*>(
               &_USER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(USER& a, USER& b) {
    a.Swap(&b);
  }
  inline void Swap(USER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(USER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  USER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<USER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const USER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const USER& from) {
    USER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(USER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.USER";
  }
  protected:
  explicit USER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kEmailFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kLocationFieldNumber = 5,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string location = 5;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:notepad.USER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// -------------------------------------------------------------------

class USER_BOOK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.USER_BOOK) */ {
 public:
  inline USER_BOOK() : USER_BOOK(nullptr) {}
  ~USER_BOOK() override;
  explicit PROTOBUF_CONSTEXPR USER_BOOK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  USER_BOOK(const USER_BOOK& from);
  USER_BOOK(USER_BOOK&& from) noexcept
    : USER_BOOK() {
    *this = ::std::move(from);
  }

  inline USER_BOOK& operator=(const USER_BOOK& from) {
    CopyFrom(from);
    return *this;
  }
  inline USER_BOOK& operator=(USER_BOOK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const USER_BOOK& default_instance() {
    return *internal_default_instance();
  }
  static inline const USER_BOOK* internal_default_instance() {
    return reinterpret_cast<const USER_BOOK*>(
               &_USER_BOOK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(USER_BOOK& a, USER_BOOK& b) {
    a.Swap(&b);
  }
  inline void Swap(USER_BOOK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(USER_BOOK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  USER_BOOK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<USER_BOOK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const USER_BOOK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const USER_BOOK& from) {
    USER_BOOK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(USER_BOOK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.USER_BOOK";
  }
  protected:
  explicit USER_BOOK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // repeated .notepad.USER user = 1;
  int user_size() const;
  private:
  int _internal_user_size() const;
  public:
  void clear_user();
  ::notepad::USER* mutable_user(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::USER >*
      mutable_user();
  private:
  const ::notepad::USER& _internal_user(int index) const;
  ::notepad::USER* _internal_add_user();
  public:
  const ::notepad::USER& user(int index) const;
  ::notepad::USER* add_user();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::USER >&
      user() const;

  // @@protoc_insertion_point(class_scope:notepad.USER_BOOK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::USER > user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// -------------------------------------------------------------------

class GIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.GIST) */ {
 public:
  inline GIST() : GIST(nullptr) {}
  ~GIST() override;
  explicit PROTOBUF_CONSTEXPR GIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GIST(const GIST& from);
  GIST(GIST&& from) noexcept
    : GIST() {
    *this = ::std::move(from);
  }

  inline GIST& operator=(const GIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline GIST& operator=(GIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const GIST* internal_default_instance() {
    return reinterpret_cast<const GIST*>(
               &_GIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GIST& a, GIST& b) {
    a.Swap(&b);
  }
  inline void Swap(GIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GIST& from) {
    GIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.GIST";
  }
  protected:
  explicit GIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGistLineFieldNumber = 1,
  };
  // string gist_line = 1;
  void clear_gist_line();
  const std::string& gist_line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gist_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gist_line();
  PROTOBUF_NODISCARD std::string* release_gist_line();
  void set_allocated_gist_line(std::string* gist_line);
  private:
  const std::string& _internal_gist_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gist_line(const std::string& value);
  std::string* _internal_mutable_gist_line();
  public:

  // @@protoc_insertion_point(class_scope:notepad.GIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gist_line_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// -------------------------------------------------------------------

class PROJECT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.PROJECT) */ {
 public:
  inline PROJECT() : PROJECT(nullptr) {}
  ~PROJECT() override;
  explicit PROTOBUF_CONSTEXPR PROJECT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PROJECT(const PROJECT& from);
  PROJECT(PROJECT&& from) noexcept
    : PROJECT() {
    *this = ::std::move(from);
  }

  inline PROJECT& operator=(const PROJECT& from) {
    CopyFrom(from);
    return *this;
  }
  inline PROJECT& operator=(PROJECT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PROJECT& default_instance() {
    return *internal_default_instance();
  }
  static inline const PROJECT* internal_default_instance() {
    return reinterpret_cast<const PROJECT*>(
               &_PROJECT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PROJECT& a, PROJECT& b) {
    a.Swap(&b);
  }
  inline void Swap(PROJECT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PROJECT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PROJECT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PROJECT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PROJECT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PROJECT& from) {
    PROJECT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PROJECT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.PROJECT";
  }
  protected:
  explicit PROJECT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGistFieldNumber = 6,
    kProjectIdFieldNumber = 1,
    kProjectNameFieldNumber = 2,
    kUserIdFieldNumber = 3,
    kPathFieldNumber = 5,
    kOperationsFieldNumber = 4,
  };
  // repeated .notepad.GIST gist = 6;
  int gist_size() const;
  private:
  int _internal_gist_size() const;
  public:
  void clear_gist();
  ::notepad::GIST* mutable_gist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::GIST >*
      mutable_gist();
  private:
  const ::notepad::GIST& _internal_gist(int index) const;
  ::notepad::GIST* _internal_add_gist();
  public:
  const ::notepad::GIST& gist(int index) const;
  ::notepad::GIST* add_gist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::GIST >&
      gist() const;

  // string project_id = 1;
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string project_name = 2;
  void clear_project_name();
  const std::string& project_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_name();
  PROTOBUF_NODISCARD std::string* release_project_name();
  void set_allocated_project_name(std::string* project_name);
  private:
  const std::string& _internal_project_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_name(const std::string& value);
  std::string* _internal_mutable_project_name();
  public:

  // string user_id = 3;
  void clear_user_id();
  const std::string& user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* user_id);
  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(const std::string& value);
  std::string* _internal_mutable_user_id();
  public:

  // string path = 5;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 operations = 4;
  void clear_operations();
  int32_t operations() const;
  void set_operations(int32_t value);
  private:
  int32_t _internal_operations() const;
  void _internal_set_operations(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:notepad.PROJECT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::GIST > gist_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    int32_t operations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// -------------------------------------------------------------------

class PROJECT_LIST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.PROJECT_LIST) */ {
 public:
  inline PROJECT_LIST() : PROJECT_LIST(nullptr) {}
  ~PROJECT_LIST() override;
  explicit PROTOBUF_CONSTEXPR PROJECT_LIST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PROJECT_LIST(const PROJECT_LIST& from);
  PROJECT_LIST(PROJECT_LIST&& from) noexcept
    : PROJECT_LIST() {
    *this = ::std::move(from);
  }

  inline PROJECT_LIST& operator=(const PROJECT_LIST& from) {
    CopyFrom(from);
    return *this;
  }
  inline PROJECT_LIST& operator=(PROJECT_LIST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PROJECT_LIST& default_instance() {
    return *internal_default_instance();
  }
  static inline const PROJECT_LIST* internal_default_instance() {
    return reinterpret_cast<const PROJECT_LIST*>(
               &_PROJECT_LIST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PROJECT_LIST& a, PROJECT_LIST& b) {
    a.Swap(&b);
  }
  inline void Swap(PROJECT_LIST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PROJECT_LIST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PROJECT_LIST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PROJECT_LIST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PROJECT_LIST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PROJECT_LIST& from) {
    PROJECT_LIST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PROJECT_LIST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.PROJECT_LIST";
  }
  protected:
  explicit PROJECT_LIST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
  };
  // repeated .notepad.PROJECT project = 1;
  int project_size() const;
  private:
  int _internal_project_size() const;
  public:
  void clear_project();
  ::notepad::PROJECT* mutable_project(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::PROJECT >*
      mutable_project();
  private:
  const ::notepad::PROJECT& _internal_project(int index) const;
  ::notepad::PROJECT* _internal_add_project();
  public:
  const ::notepad::PROJECT& project(int index) const;
  ::notepad::PROJECT* add_project();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::PROJECT >&
      project() const;

  // @@protoc_insertion_point(class_scope:notepad.PROJECT_LIST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::PROJECT > project_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// -------------------------------------------------------------------

class VERSION_POINTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:notepad.VERSION_POINTER) */ {
 public:
  inline VERSION_POINTER() : VERSION_POINTER(nullptr) {}
  ~VERSION_POINTER() override;
  explicit PROTOBUF_CONSTEXPR VERSION_POINTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VERSION_POINTER(const VERSION_POINTER& from);
  VERSION_POINTER(VERSION_POINTER&& from) noexcept
    : VERSION_POINTER() {
    *this = ::std::move(from);
  }

  inline VERSION_POINTER& operator=(const VERSION_POINTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline VERSION_POINTER& operator=(VERSION_POINTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VERSION_POINTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const VERSION_POINTER* internal_default_instance() {
    return reinterpret_cast<const VERSION_POINTER*>(
               &_VERSION_POINTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VERSION_POINTER& a, VERSION_POINTER& b) {
    a.Swap(&b);
  }
  inline void Swap(VERSION_POINTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VERSION_POINTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VERSION_POINTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VERSION_POINTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VERSION_POINTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VERSION_POINTER& from) {
    VERSION_POINTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VERSION_POINTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "notepad.VERSION_POINTER";
  }
  protected:
  explicit VERSION_POINTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kProjectIdFieldNumber = 3,
    kTimeFieldNumber = 4,
    kVersionNoFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string project_id = 3;
  void clear_project_id();
  const std::string& project_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_project_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_project_id();
  PROTOBUF_NODISCARD std::string* release_project_id();
  void set_allocated_project_id(std::string* project_id);
  private:
  const std::string& _internal_project_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_project_id(const std::string& value);
  std::string* _internal_mutable_project_id();
  public:

  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // int32 version_no = 2;
  void clear_version_no();
  int32_t version_no() const;
  void set_version_no(int32_t value);
  private:
  int32_t _internal_version_no() const;
  void _internal_set_version_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:notepad.VERSION_POINTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    int32_t version_no_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_notepad_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// USER

// string name = 1;
inline void USER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& USER::name() const {
  // @@protoc_insertion_point(field_get:notepad.USER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.USER.name)
}
inline std::string* USER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:notepad.USER.name)
  return _s;
}
inline const std::string& USER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void USER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* USER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* USER::release_name() {
  // @@protoc_insertion_point(field_release:notepad.USER.name)
  return _impl_.name_.Release();
}
inline void USER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.USER.name)
}

// string id = 2;
inline void USER::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& USER::id() const {
  // @@protoc_insertion_point(field_get:notepad.USER.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.USER.id)
}
inline std::string* USER::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:notepad.USER.id)
  return _s;
}
inline const std::string& USER::_internal_id() const {
  return _impl_.id_.Get();
}
inline void USER::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* USER::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* USER::release_id() {
  // @@protoc_insertion_point(field_release:notepad.USER.id)
  return _impl_.id_.Release();
}
inline void USER::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.USER.id)
}

// string email = 3;
inline void USER::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& USER::email() const {
  // @@protoc_insertion_point(field_get:notepad.USER.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.USER.email)
}
inline std::string* USER::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:notepad.USER.email)
  return _s;
}
inline const std::string& USER::_internal_email() const {
  return _impl_.email_.Get();
}
inline void USER::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* USER::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* USER::release_email() {
  // @@protoc_insertion_point(field_release:notepad.USER.email)
  return _impl_.email_.Release();
}
inline void USER::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.USER.email)
}

// string password = 4;
inline void USER::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& USER::password() const {
  // @@protoc_insertion_point(field_get:notepad.USER.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.USER.password)
}
inline std::string* USER::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:notepad.USER.password)
  return _s;
}
inline const std::string& USER::_internal_password() const {
  return _impl_.password_.Get();
}
inline void USER::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* USER::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* USER::release_password() {
  // @@protoc_insertion_point(field_release:notepad.USER.password)
  return _impl_.password_.Release();
}
inline void USER::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.USER.password)
}

// string location = 5;
inline void USER::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& USER::location() const {
  // @@protoc_insertion_point(field_get:notepad.USER.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void USER::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.USER.location)
}
inline std::string* USER::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:notepad.USER.location)
  return _s;
}
inline const std::string& USER::_internal_location() const {
  return _impl_.location_.Get();
}
inline void USER::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* USER::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* USER::release_location() {
  // @@protoc_insertion_point(field_release:notepad.USER.location)
  return _impl_.location_.Release();
}
inline void USER::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.USER.location)
}

// -------------------------------------------------------------------

// USER_BOOK

// repeated .notepad.USER user = 1;
inline int USER_BOOK::_internal_user_size() const {
  return _impl_.user_.size();
}
inline int USER_BOOK::user_size() const {
  return _internal_user_size();
}
inline void USER_BOOK::clear_user() {
  _impl_.user_.Clear();
}
inline ::notepad::USER* USER_BOOK::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:notepad.USER_BOOK.user)
  return _impl_.user_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::USER >*
USER_BOOK::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:notepad.USER_BOOK.user)
  return &_impl_.user_;
}
inline const ::notepad::USER& USER_BOOK::_internal_user(int index) const {
  return _impl_.user_.Get(index);
}
inline const ::notepad::USER& USER_BOOK::user(int index) const {
  // @@protoc_insertion_point(field_get:notepad.USER_BOOK.user)
  return _internal_user(index);
}
inline ::notepad::USER* USER_BOOK::_internal_add_user() {
  return _impl_.user_.Add();
}
inline ::notepad::USER* USER_BOOK::add_user() {
  ::notepad::USER* _add = _internal_add_user();
  // @@protoc_insertion_point(field_add:notepad.USER_BOOK.user)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::USER >&
USER_BOOK::user() const {
  // @@protoc_insertion_point(field_list:notepad.USER_BOOK.user)
  return _impl_.user_;
}

// -------------------------------------------------------------------

// GIST

// string gist_line = 1;
inline void GIST::clear_gist_line() {
  _impl_.gist_line_.ClearToEmpty();
}
inline const std::string& GIST::gist_line() const {
  // @@protoc_insertion_point(field_get:notepad.GIST.gist_line)
  return _internal_gist_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GIST::set_gist_line(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gist_line_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.GIST.gist_line)
}
inline std::string* GIST::mutable_gist_line() {
  std::string* _s = _internal_mutable_gist_line();
  // @@protoc_insertion_point(field_mutable:notepad.GIST.gist_line)
  return _s;
}
inline const std::string& GIST::_internal_gist_line() const {
  return _impl_.gist_line_.Get();
}
inline void GIST::_internal_set_gist_line(const std::string& value) {
  
  _impl_.gist_line_.Set(value, GetArenaForAllocation());
}
inline std::string* GIST::_internal_mutable_gist_line() {
  
  return _impl_.gist_line_.Mutable(GetArenaForAllocation());
}
inline std::string* GIST::release_gist_line() {
  // @@protoc_insertion_point(field_release:notepad.GIST.gist_line)
  return _impl_.gist_line_.Release();
}
inline void GIST::set_allocated_gist_line(std::string* gist_line) {
  if (gist_line != nullptr) {
    
  } else {
    
  }
  _impl_.gist_line_.SetAllocated(gist_line, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gist_line_.IsDefault()) {
    _impl_.gist_line_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.GIST.gist_line)
}

// -------------------------------------------------------------------

// PROJECT

// string project_id = 1;
inline void PROJECT::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& PROJECT::project_id() const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PROJECT::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.PROJECT.project_id)
}
inline std::string* PROJECT::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT.project_id)
  return _s;
}
inline const std::string& PROJECT::_internal_project_id() const {
  return _impl_.project_id_.Get();
}
inline void PROJECT::_internal_set_project_id(const std::string& value) {
  
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PROJECT::_internal_mutable_project_id() {
  
  return _impl_.project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PROJECT::release_project_id() {
  // @@protoc_insertion_point(field_release:notepad.PROJECT.project_id)
  return _impl_.project_id_.Release();
}
inline void PROJECT::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  _impl_.project_id_.SetAllocated(project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.project_id_.IsDefault()) {
    _impl_.project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.PROJECT.project_id)
}

// string project_name = 2;
inline void PROJECT::clear_project_name() {
  _impl_.project_name_.ClearToEmpty();
}
inline const std::string& PROJECT::project_name() const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.project_name)
  return _internal_project_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PROJECT::set_project_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.project_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.PROJECT.project_name)
}
inline std::string* PROJECT::mutable_project_name() {
  std::string* _s = _internal_mutable_project_name();
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT.project_name)
  return _s;
}
inline const std::string& PROJECT::_internal_project_name() const {
  return _impl_.project_name_.Get();
}
inline void PROJECT::_internal_set_project_name(const std::string& value) {
  
  _impl_.project_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PROJECT::_internal_mutable_project_name() {
  
  return _impl_.project_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PROJECT::release_project_name() {
  // @@protoc_insertion_point(field_release:notepad.PROJECT.project_name)
  return _impl_.project_name_.Release();
}
inline void PROJECT::set_allocated_project_name(std::string* project_name) {
  if (project_name != nullptr) {
    
  } else {
    
  }
  _impl_.project_name_.SetAllocated(project_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.project_name_.IsDefault()) {
    _impl_.project_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.PROJECT.project_name)
}

// string user_id = 3;
inline void PROJECT::clear_user_id() {
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& PROJECT::user_id() const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.user_id)
  return _internal_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PROJECT::set_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.PROJECT.user_id)
}
inline std::string* PROJECT::mutable_user_id() {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT.user_id)
  return _s;
}
inline const std::string& PROJECT::_internal_user_id() const {
  return _impl_.user_id_.Get();
}
inline void PROJECT::_internal_set_user_id(const std::string& value) {
  
  _impl_.user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PROJECT::_internal_mutable_user_id() {
  
  return _impl_.user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PROJECT::release_user_id() {
  // @@protoc_insertion_point(field_release:notepad.PROJECT.user_id)
  return _impl_.user_id_.Release();
}
inline void PROJECT::set_allocated_user_id(std::string* user_id) {
  if (user_id != nullptr) {
    
  } else {
    
  }
  _impl_.user_id_.SetAllocated(user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.PROJECT.user_id)
}

// int32 operations = 4;
inline void PROJECT::clear_operations() {
  _impl_.operations_ = 0;
}
inline int32_t PROJECT::_internal_operations() const {
  return _impl_.operations_;
}
inline int32_t PROJECT::operations() const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.operations)
  return _internal_operations();
}
inline void PROJECT::_internal_set_operations(int32_t value) {
  
  _impl_.operations_ = value;
}
inline void PROJECT::set_operations(int32_t value) {
  _internal_set_operations(value);
  // @@protoc_insertion_point(field_set:notepad.PROJECT.operations)
}

// string path = 5;
inline void PROJECT::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& PROJECT::path() const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PROJECT::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.PROJECT.path)
}
inline std::string* PROJECT::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT.path)
  return _s;
}
inline const std::string& PROJECT::_internal_path() const {
  return _impl_.path_.Get();
}
inline void PROJECT::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* PROJECT::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* PROJECT::release_path() {
  // @@protoc_insertion_point(field_release:notepad.PROJECT.path)
  return _impl_.path_.Release();
}
inline void PROJECT::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.PROJECT.path)
}

// repeated .notepad.GIST gist = 6;
inline int PROJECT::_internal_gist_size() const {
  return _impl_.gist_.size();
}
inline int PROJECT::gist_size() const {
  return _internal_gist_size();
}
inline void PROJECT::clear_gist() {
  _impl_.gist_.Clear();
}
inline ::notepad::GIST* PROJECT::mutable_gist(int index) {
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT.gist)
  return _impl_.gist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::GIST >*
PROJECT::mutable_gist() {
  // @@protoc_insertion_point(field_mutable_list:notepad.PROJECT.gist)
  return &_impl_.gist_;
}
inline const ::notepad::GIST& PROJECT::_internal_gist(int index) const {
  return _impl_.gist_.Get(index);
}
inline const ::notepad::GIST& PROJECT::gist(int index) const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT.gist)
  return _internal_gist(index);
}
inline ::notepad::GIST* PROJECT::_internal_add_gist() {
  return _impl_.gist_.Add();
}
inline ::notepad::GIST* PROJECT::add_gist() {
  ::notepad::GIST* _add = _internal_add_gist();
  // @@protoc_insertion_point(field_add:notepad.PROJECT.gist)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::GIST >&
PROJECT::gist() const {
  // @@protoc_insertion_point(field_list:notepad.PROJECT.gist)
  return _impl_.gist_;
}

// -------------------------------------------------------------------

// PROJECT_LIST

// repeated .notepad.PROJECT project = 1;
inline int PROJECT_LIST::_internal_project_size() const {
  return _impl_.project_.size();
}
inline int PROJECT_LIST::project_size() const {
  return _internal_project_size();
}
inline void PROJECT_LIST::clear_project() {
  _impl_.project_.Clear();
}
inline ::notepad::PROJECT* PROJECT_LIST::mutable_project(int index) {
  // @@protoc_insertion_point(field_mutable:notepad.PROJECT_LIST.project)
  return _impl_.project_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::PROJECT >*
PROJECT_LIST::mutable_project() {
  // @@protoc_insertion_point(field_mutable_list:notepad.PROJECT_LIST.project)
  return &_impl_.project_;
}
inline const ::notepad::PROJECT& PROJECT_LIST::_internal_project(int index) const {
  return _impl_.project_.Get(index);
}
inline const ::notepad::PROJECT& PROJECT_LIST::project(int index) const {
  // @@protoc_insertion_point(field_get:notepad.PROJECT_LIST.project)
  return _internal_project(index);
}
inline ::notepad::PROJECT* PROJECT_LIST::_internal_add_project() {
  return _impl_.project_.Add();
}
inline ::notepad::PROJECT* PROJECT_LIST::add_project() {
  ::notepad::PROJECT* _add = _internal_add_project();
  // @@protoc_insertion_point(field_add:notepad.PROJECT_LIST.project)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::notepad::PROJECT >&
PROJECT_LIST::project() const {
  // @@protoc_insertion_point(field_list:notepad.PROJECT_LIST.project)
  return _impl_.project_;
}

// -------------------------------------------------------------------

// VERSION_POINTER

// string id = 1;
inline void VERSION_POINTER::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& VERSION_POINTER::id() const {
  // @@protoc_insertion_point(field_get:notepad.VERSION_POINTER.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VERSION_POINTER::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.VERSION_POINTER.id)
}
inline std::string* VERSION_POINTER::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:notepad.VERSION_POINTER.id)
  return _s;
}
inline const std::string& VERSION_POINTER::_internal_id() const {
  return _impl_.id_.Get();
}
inline void VERSION_POINTER::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::release_id() {
  // @@protoc_insertion_point(field_release:notepad.VERSION_POINTER.id)
  return _impl_.id_.Release();
}
inline void VERSION_POINTER::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.VERSION_POINTER.id)
}

// int32 version_no = 2;
inline void VERSION_POINTER::clear_version_no() {
  _impl_.version_no_ = 0;
}
inline int32_t VERSION_POINTER::_internal_version_no() const {
  return _impl_.version_no_;
}
inline int32_t VERSION_POINTER::version_no() const {
  // @@protoc_insertion_point(field_get:notepad.VERSION_POINTER.version_no)
  return _internal_version_no();
}
inline void VERSION_POINTER::_internal_set_version_no(int32_t value) {
  
  _impl_.version_no_ = value;
}
inline void VERSION_POINTER::set_version_no(int32_t value) {
  _internal_set_version_no(value);
  // @@protoc_insertion_point(field_set:notepad.VERSION_POINTER.version_no)
}

// string project_id = 3;
inline void VERSION_POINTER::clear_project_id() {
  _impl_.project_id_.ClearToEmpty();
}
inline const std::string& VERSION_POINTER::project_id() const {
  // @@protoc_insertion_point(field_get:notepad.VERSION_POINTER.project_id)
  return _internal_project_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VERSION_POINTER::set_project_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.project_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.VERSION_POINTER.project_id)
}
inline std::string* VERSION_POINTER::mutable_project_id() {
  std::string* _s = _internal_mutable_project_id();
  // @@protoc_insertion_point(field_mutable:notepad.VERSION_POINTER.project_id)
  return _s;
}
inline const std::string& VERSION_POINTER::_internal_project_id() const {
  return _impl_.project_id_.Get();
}
inline void VERSION_POINTER::_internal_set_project_id(const std::string& value) {
  
  _impl_.project_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::_internal_mutable_project_id() {
  
  return _impl_.project_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::release_project_id() {
  // @@protoc_insertion_point(field_release:notepad.VERSION_POINTER.project_id)
  return _impl_.project_id_.Release();
}
inline void VERSION_POINTER::set_allocated_project_id(std::string* project_id) {
  if (project_id != nullptr) {
    
  } else {
    
  }
  _impl_.project_id_.SetAllocated(project_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.project_id_.IsDefault()) {
    _impl_.project_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.VERSION_POINTER.project_id)
}

// string time = 4;
inline void VERSION_POINTER::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& VERSION_POINTER::time() const {
  // @@protoc_insertion_point(field_get:notepad.VERSION_POINTER.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VERSION_POINTER::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:notepad.VERSION_POINTER.time)
}
inline std::string* VERSION_POINTER::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:notepad.VERSION_POINTER.time)
  return _s;
}
inline const std::string& VERSION_POINTER::_internal_time() const {
  return _impl_.time_.Get();
}
inline void VERSION_POINTER::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* VERSION_POINTER::release_time() {
  // @@protoc_insertion_point(field_release:notepad.VERSION_POINTER.time)
  return _impl_.time_.Release();
}
inline void VERSION_POINTER::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:notepad.VERSION_POINTER.time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace notepad

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_notepad_2eproto
